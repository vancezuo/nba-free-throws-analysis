# Analysis.R
# By Vance Zuo
# Script for running and visualizing some tests on processed & refined 
# NBA free throw data (run Processing.R and Refining.R first).

# This script contains some code results that were not ultimately
# included in the paper.
ft <- read.csv("ft clean.csv")

# This makes the baseline type in logistic models "Normal", as it should be
ft$type <- relevel(ft$type, "Normal")  

dim(ft)
head(ft)
whatis(ft)

# Subset of ft, for presentation purposes.
ft.main <- ft[,c("gameID", "playerFull", "result", "success",  "secondsLeft", 
                 "minutesLeft", "overtime", "prevScoreDiff", "closeness", 
                 "ahead", "clutch55", "isHomeTeam", "type", "prevTries")]

# PRELIMINARY EXPLORATION

# ft.subset() function
# Takes a column of ft and generates a table of free throw probabilities
# and 95% confidence interval bounds for each unique value in the column.
# The confidence interval is generated by binom.test(), which creates
# a Clopper-Pearson interval.
# ft must be initialized before this is called.
ft.subset <- function(col) {
  factor <- unique(col)
  made <- rep(0, length(factor))
  total <- rep(0, length(factor))
  prop <- rep(0, length(factor))
  low <- rep(0, length(factor))
  high <- rep(0, length(factor))
  for (i in 1:length(factor)) {
    this <- ft[col == factor[i],]
    made[i] <- sum(this$result == "Made")
    total[i] <- nrow(this)
    propTest <- binom.test(made[i], total[i])
    prop[i] <- propTest$estimate
    low[i] <- propTest$conf.int[1]
    high[i] <- propTest$conf.int[2]
  }
  subset <- data.frame(factor, made, total, prop, low, high)
  return(subset)
}

# ft.plot() function
# Takes a result of ft.subset() and plots it (proportion for each unique
# factor in the subset along with confidence interval lines).
# ft must be initialized before this is called.
ft.plot <- function(subset, main=NULL, xlab=NULL, ylab=NULL) {
  plot(subset$factor, subset$prop, ylim=c(0,1),
       main=main, xlab=xlab, ylab=ylab)
  grid(lty = "solid") 
  for (i in subset$factor) {
    row <- subset[subset$factor == i,]
    lines(x=c(i,i), y=c(row$low[1], row$high[1]))
  }
}

# ft.glm() function
# Returns a logistic regression model for ft with a given formula.
# ft must be initialized before this is called.
ft.glm <- function(formula) {
  return(glm(formula, data=ft, family=binomial()))
}

# PLAYER
# Data
ft.player <- ft.subset(ft$playerFull)
ft.player <- ft.player[order(ft.player$prop, decreasing=TRUE),]

# Graphics - note names are not displayed as there is no space; besides the
# aim is to provide and overview of the variation
dotchart(ft.player$prop, main="Player Free Throw Percentages", pch=20)
matlines(rbind(ft.player$low, ft.player$high),
         rbind(1:nrow(ft.player),1:nrow(ft.player)),
         col="black", lty="dashed")

# Significance Tests
# test.player compares proportion between all players
# test.player.10 restricts to players that have made/missed counts both >10
ft.player.10 <- ft.player[ft.player$made > 10 & ft.player$total > 21,]
ft.10 <- ft[ft$playerFull %in% ft.player.10$factor,]

test.player <- prop.test(table(ft$playerFull, ft$result))
test.player.10 <- prop.test(table(factor(ft.10$playerFull), ft.10$result))

# Save Test Output (for trimming)
capture.output(test.player, file="test.player.txt")
capture.output(test.player.10, file="test.player.10.txt")

# PREVIOUS SCORE DIFFERENCE
# Data
ft.diff <- ft.subset(ft$prevScoreDiff)
ft.diff <- ft.diff[order(ft.diff$factor, decreasing=TRUE),]
ft.close <- ft.subset(ft$closeness)
table.within5 <- table(ft$within5, ft$result)
table.down1 <- table(ft$down1, ft$result)
table.tie <- table(ft$tie, ft$result)
table.ahead <- table(ft$ahead, ft$result)

# Graphics
ft.plot(ft.diff, main="Free Throw % by Relative Score Difference",
        xlab="Relative Score Difference", ylab="Free Throw % Made")
ft.plot(ft.close, main="Free Throw % by Absolute Score Difference",
        xlab="Absolute Score Difference", ylab="Free Throw % Made")

mosaicplot(table.within5, main="Free Throw % when Score Difference is Within 5",
           xlab="Scores Within 5", ylab="Result")
mosaicplot(table.down1, main="Free Throws % when Down 1",
           xlab="Own Team Down 1", ylab="Result")
mosaicplot(table.tie, main="Free Throws % when Tied",
           xlab="Tie Game", ylab="Result")
mosaicplot(table.ahead, main="Free Throws % when Ahead",
           xlab="Own Team Ahead", ylab="Result")

# Significance Tests
test.within5 <- fisher.test(table.within5)
test.down1 <- fisher.test(table.down1)
test.tie <- fisher.test(table.tie)
test.ahead <- fisher.test(table.ahead)

lm.diff <- ft.glm(success ~ playerFull + prevScoreDiff)
anova.diff <- anova(lm.diff, test="Chisq")

lm.close <- ft.glm(success ~ playerFull + closeness + ahead)
anova.close <- anova(lm.close, test="Chisq")

# Save (note models with playerFull take long to compute)
capture.output(test.tie, file="test.tie.txt")
capture.output(summary(lm.down1), file="lm.down1.txt")
capture.output(summary(lm.diff), file="lm.diff.txt")
capture.output(anova.diff, file="anova.diff.txt")
capture.output(summary(lm.close), file="lm.close.txt")
capture.output(anova.close, file="anova.close.txt")

# TIME LEFT
# Data
ft.time <- ft.subset(ft$minutesLeft)
ft.time <- ft.time[order(ft.time$factor, decreasing=TRUE),]
table.under5min <- table(ft$under5min, ft$result)
table.overtime <- table(ft$overtime, ft$result)

# Graphics
mosaicplot(table.under5min, main="Free Throw % when Under 5 Minutes",
           xlab="Under 5 Minutes", ylab="Result")
mosaicplot(table.overtime, main="Free Throw % in Overtime",
           xlab="Overtime", ylab="Result")

ft.plot(ft.time, main="Free Throw % by Time Remaining",
        xlab="Minutes Remaining", ylab="Free Throw % Made")

# Significance Tests
test.under5min <- fisher.test(table.under5min)
test.overtime <- fisher.test(table.overtime)

lm.seconds <- ft.glm(success ~ playerFull + secondsLeft)
anova.seconds <- anova(lm.seconds, test="Chisq")

lm.time <- ft.glm(success ~ playerFull + closeness + secondsLeft)
anova.time <- anova(lm.time, test="Chisq")

# Save (note models with playerFull take long to compute)
capture.output(test.overtime, file="test.overtime.txt")
capture.output(summary(lm.seconds), file="lm.seconds.txt")
capture.output(anova.seconds, file="anova.seconds.only.txt")
capture.output(summary(lm.seconds), file="lm.seconds.txt")
capture.output(anova.seconds, file="anova.seconds.only.txt")
capture.output(summary(lm.time), file="lm.time.txt")
capture.output(anova.time, file="anova.time.txt")

# CLUTCH (Minutes Under 5, Score Within 5)
# A completely arbritrary definition, based on basketball statistics
# website http://www.82games.com: "4th quarter or overtime, 
# less than 5 minutes left, neither team ahead by more than 5 points".
# Other choices possible, but I had to settle on something.

# Data
ft.clutch55 <- ft.subset(ft$clutch55)
table.clutch <- table(ft$clutch55, ft$result)
test.clutch <- fisher.test(table.clutch)

# Graphics
mosaicplot(table.clutch, main="Free Throw % in the Clutch",
           xlab="Minutes Under 5 and Scores Within 5", ylab="Result")

# Significance Tests 
lm.clutch <- ft.glm(success ~ playerFull + closeness + clutch55)
anova.clutch <- anova(lm.clutch, test="Chisq")

# Save (note models with playerFull take long to compute)
capture.output(test.clutch , file="test.clutch.txt")
capture.output(summary(lm.clutch), file="lm.clutch.txt")
capture.output(anova.clutch, file="anova.clutch.txt")

# HOME COURT
# Data
ft.home <- ft.subset(ft$isHomeTeam)
table.home <- table(ft$isHomeTeam, ft$result)

# Graphics
mosaicplot(table.home, main="Free Throw % at Home",
           xlab="Player is at Home", ylab="Result")

# Significance Tests
test.home <- fisher.test(table.home)

lm.home <- ft.glm(success ~ playerFull + closeness + isHomeTeam)

# Save (note models with playerFull take long to compute)
capture.output(summary(lm.home), file="lm.home.txt")

# TYPE (Normal, Technical, Flagrant)
# Data
ft.type <- ft.subset(ft$type)
table.type <- table(type=relevel(ft$type, "Technical"), result=ft$result)

# Graphics
plot.type <- mosaicplot(table.type, main="Free Throw % by Type",
                        xlab="Free Throw Type", ylab="Result")

# Significance Tests
test.type <- fisher.test(table.type)

lm.type <- ft.glm(success ~ playerFull + closeness + type)
anova.type <- anova(lm.type, test="ChiSq")

# Save (note models with playerFull take long to compute)
capture.output(summary(lm.type), file="lm.type.txt")
capture.output(anova.type , file="anova.type.txt")

# PREVIOUS TRIES
# This is the number of immediate attempts the player had beforehand, coming
# from the SAME foul.

# Data
ft.number <- ft.subset(as.factor(ft$thisNumber))
table.number <- table(as.factor(ft$thisNumber), ft$result)

# Graphics
mosaicplot(table.number, main="Free Throw % by Number",
           xlab="Free Throw Number", ylab="Result")

# Significance Tests
lm.tries <- ft.glm(success ~ playerFull + closeness + type + prevTries)
anova.tries <- anova(lm.tries, test="Chisq")

# Save (note models with playerFull take long to compute)
capture.output(summary(lm.tries), file="lm.tries.txt")
dput(anova.tries, "anova.tries.txt")

# LINEAR MODEL EXPLORATION

# Intercept only
lm.simple <- ft.glm(success ~ 1)

# All Explored Variables EXCEPT Player
lm.noplayer <- ft.glm(success ~ prevTries + type + closeness + secondsLeft + 
                        clutch55 + ahead + isHomeTeam)

# Significant Variables 
# noclose excludes closeness, semisig adds variables secondsLeft 
lm.sig.noclose <- ft.glm(success ~ playerFull + prevTries + type)
lm.sig <- ft.glm(success ~ playerFull + prevTries + type + closeness)
lm.semisig <- ft.glm(success ~ playerFull + prevTries + type + closeness + 
                       secondsLeft)

# All Variables
# noclutch excludes clutch55, noclutch.interact is noclutch but with interaction
# between closeness and secondsLeft, clutch excludes closeness and secondsLeft,
# clutch.first places clutch55 before secondsLeft, reverse places the variables
# reverse their original order
lm.all <- ft.glm(success ~ playerFull + prevTries + type + 
                   closeness + secondsLeft + clutch55 + ahead + isHomeTeam)
lm.all.noclutch <- ft.glm(success ~ playerFull + prevTries + type + 
                         closeness + secondsLeft + ahead + isHomeTeam)
lm.all.noclutch.interact <- ft.glm(success ~ playerFull + prevTries + type + 
                         closeness * secondsLeft + ahead + isHomeTeam)
lm.all.clutch <- ft.glm(success ~ playerFull + prevTries + type + 
                          clutch55 + ahead + isHomeTeam)
lm.all.reverse <- ft.glm(success ~ isHomeTeam + ahead + clutch55 + 
                           secondsLeft + closeness + 
                           type + prevTries + playerFull)

# ANOVA of the lm.all models 
anova.all <- anova(lm.all, test="Chisq")
anova.all.noclutch <- anova(lm.all.noclutch, test="Chisq")
anova.all.clutch <- anova(lm.all.clutch, test="Chisq")
anova.all.reverse <- anova(lm.all.reverse, test="Chisq")

# Save (note models with playerFull take long to compute)
capture.output(summary(lm.noplayer), file="lm.noplayer.txt")
capture.output(summary(lm.sig.noclose), file="lm.sig.noclose.txt")
capture.output(summary(lm.sig), file="lm.sig.txt")
capture.output(summary(lm.semisig), file="lm.semisig.txt")
capture.output(summary(lm.all), file="lm.all.txt")
capture.output(summary(lm.all.noclutch), file="lm.all.noclutch.txt")
capture.output(summary(lm.all.noclutch.interact), 
               file="lm.all.noclutch.interact.txt")
capture.output(summary(lm.all.clutch), file="lm.all.clutch.txt")
capture.output(summary(lm.all.reverse), file="lm.all.reverse.txt")
capture.output(anova.all, file="anova.all.txt")
capture.output(anova.all.noclutch, file="anova.all.noclutch.txt")
capture.output(anova.all.clutch, file="anova.all.clutch.txt")
capture.output(anova.all.reverse, file="anova.all.reverse.txt")

# TESTING MODEL ACCURACY

# Fitted Probabilities 
fitted.coin <- rep(0.5, length(ft$success))
fitted.simple <- lm.simple$fitted
fitted.player <- lm.player$fitted
fitted.semisig <- lm.semisig$fitted
fitted.all <- lm.all$fitted

# Save Prediction Probabilities
dput(fitted.simple, file="fitted.simple.txt")
dput(fitted.player, file="fitted.player.txt")
dput(fitted.semisig, file="fitted.semisig.txt")
dput(fitted.all, file="fitted.all.txt")

# ft.fitted.test() function
# Runs simulations of fitted probabilities for ft success to evaluate a
# model's effectiveness at predicting free throws
ft.fitted.test <- function(fitted, trials=10000) {
  success.rates <- rep(NA, trials)
  for (i in 1:trials) {
    rand <- runif(length(fitted))
    predict <- rand < fitted
    success.rates[i] <- mean(predict == ft$success)
  }
  return(mean(success.rates))
}

# Test Probabilities through simulation
# Listed probabilities hold for the random seeds that are set beforehand
set.seed(1)
ft.fitted.test(fitted.coin)    # 0.5000025
set.seed(2)
ft.fitted.test(fitted.simple)  # 0.6279874
set.seed(3)
ft.fitted.test(fitted.player)  # 0.6512397
set.seed(4)
ft.fitted.test(fitted.semisig) # 0.652533
set.seed(5)
ft.fitted.test(fitted.all)     # 0.6525422

# INDIVIDUAL PLAYER MODELS
# Ultimately unused, because there is no good baseline to compare the
# individual player models to. The best practice would be interacting
# playerFull with other variables; however, due to the large number of
# players my computer does not have enough memory for this to be feasible.

# ft.model() function
# Generates logistic models with the given vars for each player in ft,
# returning the result in table format with coefficients of each player's
# model on each row. ft must be initialized before this is called.
library(plyr)
ft.model <- function(vars) {
  models <- ddply(ft, "playerFull", function(x) {
    formula <- "result ~ 1"
    for (var in vars) {
      if (length(unique(x[,eval(var)])) > 1)
        formula <- paste(formula, " + ", var)
    }
    model <- glm(as.formula(formula), data=x, family=binomial())
    coef <- summary(model)$coef
    Coefficient <- rownames(coef)
    return(cbind(Coefficient, coef))
  })
  models$Estimate <- as.numeric(as.character(models$Estimate))
  models$"Std. Error" <- as.numeric(as.character(models$"Std. Error"))
  models$"z value" <- as.numeric(as.character(models$"z value"))
  models$"Pr(>|z|)" <- as.numeric(as.character(models$"Pr(>|z|)"))
  return(models)
}